#include <iostream>
using namespace std;

#define MAX 100

class queue_{
private:
    int capacity, front, back;
    char *queue;
    void doublecapacity();

public:
    queue_():capacity(5), front(0), back(0){
        queue = new char[capacity];
    }
    void push(char x);
    void pop();
    bool isempty();
    bool isfull();
    char getfront();
    char getback();
    int getsize();
    void show();
    //int getcapacity();
};

class stack_{
private:
    int top;
    int capacity;
    char *stack;
    void doublecapacity();
public:
    stack_():top(-1), capacity(10)
    {
        stack = new char[capacity];
    }
    void push(char x);
    void pop();
    bool isempty();
    char gettop();
    int getsize();
};

void queue_::doublecapacity()
{
    char *newqueue = new char[capacity*2];

    int j=front, size = getsize();

    for(int i=1; i<=size; i++)
    {
        newqueue[i] = queue[++j % capacity];
    }
    back = getsize();
    front = 0;
    capacity *= 2;
    delete [] queue;
    queue = newqueue;
}

void queue_::push(char x)
{
    if(isfull())
    {
        doublecapacity();
    }
    back = (back + 1)%capacity;
    queue[back] = x;
}

void queue_::pop()
{
    if(isempty())
    {
        cout<<"queue is empty"<<endl;
        return;
    }
    front = (front + 1)%capacity;
}

bool queue_::isempty()
{
    return (front == back);
}

bool queue_::isfull()
{
    return ((back+1)%capacity == front);
}

char queue_::getfront()
{
    if(isempty())
    {
        cout<<"queue is empty"<<endl;
        return 'l';
    }
    return queue[(front + 1)%capacity];
}

char queue_::getback()
{
    if(isempty())
    {
        cout<<"queue is empty"<<endl;
        return 'l';
    }
    return queue[back];
}

int queue_::getsize()
{
    int size;
    if(front<back)
    {
        size = back-front;
    }
    else
        size = capacity - (front-back);
    return size;
}

void printqueue(queue_ queue)
{
    cout<<"front: "<<queue.getfront()<<"    back: "<<queue.getback()<<endl;
    cout<<"number of elements: "<<queue.getsize()<<endl;
    cout<<endl;
}



void stack_::doublecapacity()
{
    capacity *= 2;
    char *newstack = new char[capacity];
    for(int i=0; i<capacity/2; i++)
    {
        newstack[i] = stack[i];
    }
    delete [] stack;
    stack = newstack;
}

void stack_::push(char x)
{
    if(top == capacity-1) doublecapacity();
    stack[++top] = x;
}
void stack_::pop()
{
    if(isempty())
    {
        cout<<"stack is empty"<<endl;
        return;
    }
    top--;
}

bool stack_::isempty()
{
    if(top == -1)
        return true;
    else
        return false;
}

char stack_::gettop()
{
    if(isempty())
    {
        cout<<"stack is empty"<<endl;
        return '!';
    }
    return stack[top];

}

int stack_::getsize()
{
    return top+1;
}


int find_maxtop(int *mattop, int c)
{
    int tmp = 0;
    for(int i=0; i<c; i++)
    {
        if(mattop[tmp]<=mattop[i])
            tmp = i;
    }
    return tmp;
}


void bomb(char **arr, int col, int row, int c, int *mattop)
{
    //col-1
    if(mattop[col-1] == row-1)
    {
        arr[row-1][col-1] = '_';
        mattop[col-1]--;
    }
    else if(mattop[col-1] == row)
    {
        arr[row][col-1] = '_';
        arr[row-1][col-1] = '_';
        mattop[col-1] = mattop[col-1]-2;
    }
    else if(mattop[col-1] == row+1)
    {
        arr[row+1][col-1] = '_';
        arr[row][col-1] = '_';
        arr[row-1][col-1] = '_';
        mattop[col-1] = mattop[col-1]-3;
    }
    else if(mattop[col-1] > row+1)
    {
        arr[row+1][col-1] = '_';
        arr[row][col-1] = '_';
        arr[row-1][col-1] = '_';
    }
    //col+1
    if(mattop[col+1] == row-1)
    {
        arr[row-1][col+1] = '_';
        mattop[col+1]--;
    }
    else if(mattop[col+1] == row)
    {
        arr[row][col+1] = '_';
        arr[row-1][col+1] = '_';
        mattop[col+1] = mattop[col+1]-2;
    }
    else if(mattop[col+1] == row+1)
    {
        arr[row+1][col+1] = '_';
        arr[row][col+1] = '_';
        arr[row-1][col+1] = '_';
        mattop[col+1] = mattop[col+1]-3;
    }
    else if(mattop[col+1] > row+1)
    {
        arr[row+1][col+1] = '_';
        arr[row][col+1] = '_';
        arr[row-1][col+1] = '_';
    }
    //col
    arr[row][col] = '_';
    arr[row-1][col] = '_';
    mattop[col] = mattop[col]-2;
    return;
}

void flash(char **arr, int c, int *mattop)
{
    int top = find_maxtop(mattop, c);
    cout<<"MINE LEVEL:"<<top<<endl;
    for(int i=0; i<c; i++)
        cout<<arr[top][i]<<" ";
    cout<<endl;
    return;
}

void pig(char **arr, stack_ pack)
{
    if(pack.isempty()) return;
    while(pack.gettop() != 'D')
    {
        pack.pop();
    }
    return;
}

char gold_dia(char **arr, int num, int *mattop)
{
    int top = mattop[num];
    for(int i=0; i<top; i++)
    {
        if (arr[i][num] == 'G')
            return 'G';
        else if(arr[i][num] == 'D')
            return 'D';
    }
    return 'N';
}

void lucky(char **arr, int num, int *mattop, int c, queue_ inv, stack_ pack)
{
    char topic = gold_dia(arr, num, mattop);
    int max_top = find_maxtop(mattop, c);
    if(topic == 'N') return;
    for(int k=1; k<=3; k++)
    {
        if(num-2>=0)
        {
            arr[max_top+k][num-2] = topic;
            mattop[num-2]++;
        }
        if(num-1>=0)
        {
            arr[max_top+k][num-1] = topic;
            mattop[num-1]++;
        }
        arr[max_top+k][num] = topic;
        mattop[num]++;
        if(num+1<c)
        {
            arr[max_top+k][num+1] = topic;
            mattop[num+1]++;
        }
        if(num+2<c)
        {
            arr[max_top+k][num+2] = topic;
            mattop[num+2]++;
        }
    }

}

void mag(char **arr, int c, int *mattop, queue_ inv, stack_ pack)
{
    for(int i=0; i<c; i++)
    {
        if(arr[mattop[i]][i] == 'M')
        {
            inv.push(arr[mattop[i]][i]);
            arr[mattop[i]][i] = '_';
            mattop[i]--;
        }
        else if(arr[mattop[i]][i] == 'F')
        {
            inv.push(arr[mattop[i]][i]);
            arr[mattop[i]][i] = '_';
            mattop[i]--;
        }
        else if(arr[mattop[i]][i] == 'D')
        {
            pack.push(arr[mattop[i]][i]);
            arr[mattop[i]][i] = '_';
            mattop[i]--;
        }
        else if(arr[mattop[i]][i] == 'G')
        {
            pack.push(arr[mattop[i]][i]);
            arr[mattop[i]][i] = '_';
            mattop[i]--;
        }
        else if(arr[mattop[i]][i] == 'P')
        {
            pig(arr, pack);
            arr[mattop[i]][i] = '_';
            mattop[i]--;
        }

        else if(arr[mattop[i]][i] == 'C')
        {
            lucky(arr, i, mattop, c, inv, pack);
            arr[mattop[i]][i] = '_';
        }
        else if(arr[mattop[i]][i] == 'B')
        {
            bomb(arr, i, mattop[i], c, mattop);
            arr[mattop[i]][i] = '_';
        }
    }
    return;
}







void dig(char **arr, int num, int *mattop, queue_ inv, stack_ pack, int c)
{
    if(arr[mattop[num]][num] == 'G' || arr[mattop[num]][num] == 'D')
    {
        pack.push(arr[mattop[num]][num]);
        arr[mattop[num]][num] = '_';
        mattop[num]--;
        return;
    }

    else if(arr[mattop[num]][num] == 'F')
    {
        inv.push(arr[mattop[num]][num]);
        arr[mattop[num]][num] = '_';
        mattop[num]--;
        return;
    }
    else if(arr[mattop[num]][num] == 'M')
    {
        inv.push(arr[mattop[num]][num]);
        arr[mattop[num]][num] = '_';
        mattop[num]--;
        return;
    }
    else if(arr[mattop[num]][num] == 'C')//instant
    {
        lucky(arr, num, mattop, c, inv, pack);
        arr[mattop[num]][num] = '_';
        return;
    }
    else if(arr[mattop[num]][num] == 'P')//instant
    {
        pig(arr, pack);
        arr[mattop[num]][num] = '_';
        mattop[num]--;
        return;
    }
    else if(arr[mattop[num]][num] == 'B')//instant
    {
        bomb(arr, num, mattop[num], c, mattop);
    }
}

void use(char **arr, int c, int *mattop, queue_ inv, stack_ pack)
{
    if(inv.isempty()) return;
    if(inv.getfront() == 'M')
    {
        mag(arr, c, mattop, inv, pack);
        inv.pop();
        return;
    }
    else if(inv.getfront() == 'F')
    {
        flash(arr, c, mattop);
        inv.pop();
        return;
    }
}



void remap(char **arr, int *mattop, int c)
{
    int top = find_maxtop(mattop, c);
    for(int j=0; j<c; j++)
    {
        int i = mattop[j]+1;
        while(top >= mattop[j])
        {
            arr[i][j] = '_';
            i++;
        }
    }
    return;
}

int main()
{
    int c, r, n;

    string op;
    int num;
    char tmp;
    char **arr = new char *[r];
    cin>>c>>r>>n;
    int *mattop = new int [c];
    queue_ inv;
    stack_ pack;
    for(int i=0; i<r; i++)
        arr[i] = new char[c];
    for(int i=0; i<c; i++)
        mattop[i] = r;

    for(int i=r; i>0; i--)
    {
        for(int j=0; j<c; j++)
        {
            cin>>tmp;
            arr[i-1][j] = tmp;
        }
    }
    /*
    for(int i=0; i<r; i++)
    {
        for(int j=0; j<c; j++)
        {
            cout<<arr[r-i][j]<<" ";
        }
        cout<<endl;
    }
    */

    while(n--)
    {
        cin >> op;
        if(op == "DIG")
        {
            cin>>num;
            dig(arr, num, mattop, inv, pack, c);
        }
        if(op == "USE")
        {
            use(arr, c, mattop, inv, pack);
        }
    }

    while(!pack.isempty())
    {
        cout<<pack.gettop()<<" ";
        pack.pop();
    }
    cout<<endl;
    remap(arr, mattop, c);
    int top = find_maxtop(mattop, c);
    cout<<"FINAL MAP:"<<endl;
    for(int i=top; i>0; i--)
    {
        for(int j=0; j<c; j++)
        {
            cout<<arr[i-1][j]<<" ";
        }
        cout<<endl;
    }

    return 0;
}
